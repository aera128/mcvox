
#include <mc/schematic.hpp>
#include <mc/value.hpp>
#include <io/gzip_stream.hpp>

namespace mc {

struct color_entry {
	color_entry(color::value c, unsigned char block, unsigned char data) : c(c), block(block), data(data) { }

	color::value  c;
	unsigned char block;
	unsigned char data;
};
typedef std::vector<color_entry> color_entries;

color_entries initCE() {
	color_entries result;
#	define CE(rgb,block,data) result.push_back(color_entry(color::make(rgb), block, data))
	CE(0x7d7d7d,0x1,0x00);
	CE(0x997162,0x1,0x1);
	CE(0x9f7262,0x1,0x2);
	CE(0xb3b3b6,0x1,0x3);
	CE(0xb7b7b9,0x1,0x4);
	CE(0x828383,0x1,0x5);
	CE(0x858586,0x1,0x6);
	CE(0x866043,0x3,0x00);
	CE(0x7a7a7a,0x4,0x00);
	CE(0x9c7f4e,0x5,0x00);
	CE(0x674d2e,0x5,0x1);
	CE(0xc3b37b,0x5,0x2);
	CE(0x9a6e4d,0x5,0x3);
	CE(0xa95b33,0x5,0x4);
	CE(0x3d2712,0x5,0x5);
	CE(0x535353,0x7,0x00);
	CE(0xdbd3a0,0xc,0x00);
	CE(0xa95821,0xc,0x1);
	CE(0x665131,0x11,0xc);
	CE(0x2d1c0c,0x11,0xd);
	CE(0xcecec9,0x11,0xe);
	CE(0x57431a,0x11,0xf);
	CE(0xc2c354,0x13,0x00);
	CE(0x264389,0x16,0x00);
	CE(0xdad29e,0x18,0x00);
	CE(0x644332,0x19,0x00);
	CE(0xdddddd,0x23,0x00);
	CE(0xdb7d3e,0x23,0x1);
	CE(0xb350bc,0x23,0x2);
	CE(0x6a8ac9,0x23,0x3);
	CE(0xb1a627,0x23,0x4);
	CE(0x41ae38,0x23,0x5);
	CE(0xd08499,0x23,0x6);
	CE(0x404040,0x23,0x7);
	CE(0x9aa1a1,0x23,0x8);
	CE(0x2e6e89,0x23,0x9);
	CE(0x7e3db5,0x23,0xa);
	CE(0x2e388d,0x23,0xb);
	CE(0x4f321f,0x23,0xc);
	CE(0x35461b,0x23,0xd);
	CE(0x963430,0x23,0xe);
	CE(0x191616,0x23,0xf);
	CE(0xf9ec4e,0x29,0x00);
	CE(0xdbdbdb,0x2a,0x00);
	CE(0x9f9f9f,0x2b,0x00);
	CE(0xdad29e,0x2b,0x1);
	CE(0x9c7f4e,0x2b,0x2);
	CE(0x7a7a7a,0x2b,0x3);
	CE(0x926356,0x2b,0x4);
	CE(0x7a7a7a,0x2b,0x5);
	CE(0x2c161a,0x2b,0x6);
	CE(0xece9e2,0x2b,0x7);
	CE(0xdad29e,0x2b,0x9);
	CE(0x9c7f4e,0x2b,0xa);
	CE(0x7a7a7a,0x2b,0xb);
	CE(0x926356,0x2b,0xc);
	CE(0x7a7a7a,0x2b,0xd);
	CE(0x2c161a,0x2b,0xe);
	CE(0xece9e2,0x2b,0xf);
	CE(0x926356,0x2d,0x00);
	CE(0x9c7f4e,0x2f,0x00);
	CE(0x677967,0x30,0x00);
	CE(0x14121d,0x31,0x00);
	CE(0x9c7f4e,0x35,0x00);
	CE(0x61dbd5,0x39,0x00);
	CE(0x7dadff,0x4f,0x00);
	CE(0xeffbfb,0x50,0x00);
	CE(0x9ea4b0,0x52,0x00);
	CE(0xc07615,0x56,0x00);
	CE(0x6f3634,0x57,0x00);
	CE(0x544033,0x58,0x00);
	CE(0x8f7645,0x59,0x00);
	CE(0xc07615,0x5b,0x00);
	CE(0x7a7a7a,0x62,0x00);
	CE(0x72776a,0x62,0x1);
	CE(0x767676,0x62,0x2);
	CE(0x767676,0x62,0x3);
	CE(0xcaab78,0x63,0x00);
	CE(0x8d6a53,0x63,0xe);
	CE(0xcfccc2,0x63,0xf);
	CE(0xcaab78,0x64,0x00);
	CE(0xb62524,0x64,0xe);
	CE(0xcfccc2,0x64,0xf);
	CE(0x979924,0x67,0x00);
	CE(0x2c161a,0x70,0x00);
	CE(0x2c161a,0x72,0x00);
	CE(0xdddfa5,0x79,0x00);
	CE(0x462b1a,0x7b,0x00);
	CE(0x9c7f4e,0x7d,0x00);
	CE(0x674d2e,0x7d,0x1);
	CE(0xc3b37b,0x7d,0x2);
	CE(0x9a6e4d,0x7d,0x3);
	CE(0xa95b33,0x7d,0x4);
	CE(0x3d2712,0x7d,0x5);
	CE(0x674d2e,0x7d,0x9);
	CE(0xc3b37b,0x7d,0xa);
	CE(0x9a6e4d,0x7d,0xb);
	CE(0xa95b33,0x7d,0xc);
	CE(0x3d2712,0x7d,0xd);
	CE(0x51d975,0x85,0x00);
	CE(0xab1b09,0x98,0x00);
	CE(0xece9e2,0x9b,0x00);
	CE(0xe7e4db,0x9b,0x1);
	CE(0xe8e5dd,0x9b,0x2);
	CE(0xe7e3db,0x9b,0x3);
	CE(0xe7e3db,0x9b,0x4);
	CE(0xece9e2,0x9c,0x00);
	CE(0xd1b2a1,0x9f,0x00);
	CE(0xa15325,0x9f,0x1);
	CE(0x95586c,0x9f,0x2);
	CE(0x716c89,0x9f,0x3);
	CE(0xba8523,0x9f,0x4);
	CE(0x677534,0x9f,0x5);
	CE(0xa14e4e,0x9f,0x6);
	CE(0x392a23,0x9f,0x7);
	CE(0x876a61,0x9f,0x8);
	CE(0x565b5b,0x9f,0x9);
	CE(0x764656,0x9f,0xa);
	CE(0x4a3b5b,0x9f,0xb);
	CE(0x4d3323,0x9f,0xc);
	CE(0x4c532a,0x9f,0xd);
	CE(0x8f3d2e,0x9f,0xe);
	CE(0x251610,0x9f,0xf);
	CE(0x696359,0xa2,0xc);
	CE(0x2d1c0c,0xa2,0xd);
	CE(0x6aaa96,0xa8,0x00);
	CE(0x63a08f,0xa8,0x1);
	CE(0x3b574b,0xa8,0x2);
	CE(0xacc8be,0xa9,0x00);
	CE(0xa88b10,0xaa,0x00);
	CE(0x965c42,0xac,0x00);
	CE(0x121212,0xad,0x00);
	CE(0xa5c2f5,0xae,0x00);
	CE(0xa6551d,0xb3,0x00);
	CE(0xa6551d,0xb5,0x00);
	CE(0xa6551d,0xb6,0x00);
	CE(0xdddddd,0xeb,0x00);
	CE(0xdb7d3e,0xec,0x00);
	CE(0xb350bc,0xed,0x00);
	CE(0x6a8ac9,0xee,0x00);
	CE(0xb1a627,0xef,0x00);
	CE(0x41ae38,0xf0,0x00);
	CE(0xd08499,0xf1,0x00);
	CE(0x404040,0xf2,0x00);
	CE(0x9aa1a1,0xf3,0x00);
	CE(0x2e6e89,0xf4,0x00);
	CE(0x7e3db5,0xf5,0x00);
	CE(0x2e388d,0xf6,0x00);
	CE(0x4f321f,0xf7,0x00);
	CE(0x35461b,0xf8,0x00);
	CE(0x963430,0xf9,0x00);
	CE(0x191616,0xfa,0x00);
	CE(0xdddddd,0xfb,0x00);
	CE(0xdb7d3e,0xfb,0x1);
	CE(0xb350bc,0xfb,0x2);
	CE(0x6a8ac9,0xfb,0x3);
	CE(0xb1a627,0xfb,0x4);
	CE(0x41ae38,0xfb,0x5);
	CE(0xd08499,0xfb,0x6);
	CE(0x404040,0xfb,0x7);
	CE(0x9aa1a1,0xfb,0x8);
	CE(0x2e6e89,0xfb,0x9);
	CE(0x7e3db5,0xfb,0xa);
	CE(0x2e388d,0xfb,0xb);
	CE(0x4f321f,0xfb,0xc);
	CE(0x35461b,0xfb,0xd);
	CE(0x963430,0xfb,0xe);
	CE(0x191616,0xfb,0xf);
	CE(0xdddddd,0xfc,0x00);
	CE(0xdb7d3e,0xfc,0x1);
	CE(0xb350bc,0xfc,0x2);
	CE(0x6a8ac9,0xfc,0x3);
	CE(0xb1a627,0xfc,0x4);
	CE(0x41ae38,0xfc,0x5);
	CE(0xd08499,0xfc,0x6);
	CE(0x404040,0xfc,0x7);
	CE(0x9aa1a1,0xfc,0x8);
	CE(0x2e6e89,0xfc,0x9);
	CE(0x7e3db5,0xfc,0xa);
	CE(0x2e388d,0xfc,0xb);
	CE(0x4f321f,0xfc,0xc);
	CE(0x35461b,0xfc,0xd);
	CE(0x963430,0xfc,0xe);
	CE(0x191616,0xfc,0xf);
	return result;
}

static color_entries color_map = initCE();

void toMCVoxel(color::value c, unsigned char& block, unsigned char& data) {
	if (color::alpha(c) <= 128) {
		// this voxel looks clear, make it air
		block = 0;
		data  = 0;
	} else {
		unsigned int i  = 0;
		double       md = color::distsq(c, color_map[0].c);

		for (unsigned int t = 1; t < color_map.size(); ++t) {
			double td = color::distsq(c, color_map[t].c);
			if (td < md) {
				md = td;
				i  = t;
			}
		}

		block = color_map[i].block;
		data  = color_map[i].data;
	}
}

void save(const geom::volume& v, const std::string& filename, PROGRESSFN pfn) {
	unsigned int cx = v.width();
	unsigned int cy = v.height();
	unsigned int cz = v.depth();

	// try to open the compressed output stream
	io::gzip_ostream<char> out(filename);

	// make the MC value to wrap this data
	tuple* x = new tuple("Schematic");
	x->unbox().push_back(new int2("Width",  short(cx)));
	x->unbox().push_back(new int2("Length", short(cz)));
	x->unbox().push_back(new int2("Height", short(cy)));
	x->unbox().push_back(new string("Materials", "Alpha"));

	bytes* blocks       = new bytes("Blocks");
	bytes* datas        = new bytes("Data");
	array* entities     = new array("Entities", hvalues(tuple::tagID(), values()));
	array* tileEntities = new array("TileEntities", hvalues(tuple::tagID(), values()));

	x->unbox().push_back(blocks);
	x->unbox().push_back(datas);
	x->unbox().push_back(entities);
	x->unbox().push_back(tileEntities);

	// voxelize the input volume
	typedef std::vector<unsigned char> BVec;
	BVec& blocksv = blocks->unbox();
	BVec& datasv  = datas->unbox();
	
	blocksv.reserve(cx * cy * cz);
	datasv.reserve(cx * cy * cz);

	for (unsigned int y = 0; y < cy; ++y) {
		for (unsigned int z = 0; z < cz; ++z) {
			if (pfn) {
				pfn("Writing voxels", y + (cy * z), cy * cz);
			}

			for (unsigned int x = 0; x < cx; ++x) {
				unsigned char block = 0;
				unsigned char data  = 0;

				toMCVoxel(v.voxel(x, y, z), block, data);
				blocksv.push_back(block);
				datasv.push_back(data);
			}
		}
	}

	// write the complete volume and we're done
	write(x, out);
	delete x;
}

}

